# LLVM IR Comparison: Working vs Failing

This document shows the actual LLVM IR generated by the two versions.

## Working Version (21 lines)

From commit c58fdb6 - Simple direct syscall program.

```llvm
; ModuleID = 'entrypoint.bc'
source_filename = "root"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "bpfel-unknown-unknown-unknown"

@__anon_241 = internal unnamed_addr constant [12 x i8] c"Hello world!", align 1
@builtin.zig_backend = internal unnamed_addr constant i64 2, align 8
@start.simplified_logic = internal unnamed_addr constant i1 false, align 1
@builtin.output_mode = internal unnamed_addr constant i2 1, align 1
@builtin.link_mode = internal unnamed_addr constant i1 false, align 1

; Function Attrs: minsize noredzone nounwind optsize uwtable
define dso_local i64 @entrypoint(ptr nonnull align 1 %0) #0 {
  call fastcc void inttoptr (i64 544561597 to ptr)(ptr nonnull readonly align 1 @__anon_241, i64 12) #1
  ret i64 0
}

attributes #0 = { minsize noredzone nounwind optsize uwtable "frame-pointer"="none" "no-builtins" "target-cpu"="v3" "target-features"="+alu32,-dummy,-dwarfris" }
attributes #1 = { nobuiltin }

!llvm.module.flags = !{}
```

**Key Characteristics:**
- Single function `@entrypoint`
- Direct syscall via `inttoptr`
- No complex types
- No LLVM intrinsics
- Straightforward control flow

**Result:** ✅ sbpf-linker processes successfully

## Failing Version (834 lines)

From branch feature/zignocchio-sdk - SDK with entrypoint deserialization.

Full IR available in repository at `entrypoint.ll` (834 lines).

**First 100 lines showing problematic patterns:**

; ModuleID = 'entrypoint.bc'
source_filename = "root"
target datalayout = "e-m:e-p:64:64-i64:64-i128:128-n32:64-S128"
target triple = "bpfel-unknown-unknown-unknown"

%Target.Cpu.Feature.Set = type { [5 x i64] }
%Target.Cpu = type { ptr, %Target.Cpu.Feature.Set, i6, [7 x i8] }
%Target.Cpu.Model = type { { ptr, i64 }, { ptr, i64 }, %Target.Cpu.Feature.Set }
%Target.DynamicLinker = type { [255 x i8], i8 }
%builtin.CallingConvention.CommonOptions = type { { i64, i8, [7 x i8] } }
%sdk.types.AccountInfo = type { ptr }
%sdk.types.Account = type { i8, i8, i8, i8, i32, [32 x i8], [32 x i8], i64, i64 }
%"sdk.types.RefMut([]u8)" = type { { ptr, i64 }, ptr, i8, [7 x i8] }

@__anon_994 = internal unnamed_addr constant [26 x i8] c"Counter program: starting\00", align 1
@__anon_1001 = internal unnamed_addr constant [27 x i8] c"Error: Not enough accounts\00", align 1
@__anon_1017 = internal unnamed_addr constant [36 x i8] c"Error: Counter account not writable\00", align 1
@__anon_1031 = internal unnamed_addr constant [44 x i8] c"Error: Counter account not owned by program\00", align 1
@__anon_1045 = internal unnamed_addr constant [33 x i8] c"Error: Counter account too small\00", align 1
@__anon_1068 = internal unnamed_addr constant [23 x i8] c"Current counter value:\00", align 1
@__anon_1093 = internal unnamed_addr constant [24 x i8] c"Error: Counter overflow\00", align 1
@__anon_1108 = internal unnamed_addr constant [20 x i8] c"Incremented counter\00", align 1
@__anon_1115 = internal unnamed_addr constant [25 x i8] c"Error: Counter underflow\00", align 1
@__anon_1121 = internal unnamed_addr constant [20 x i8] c"Decremented counter\00", align 1
@__anon_1126 = internal unnamed_addr constant [14 x i8] c"Reset counter\00", align 1
@__anon_1132 = internal unnamed_addr constant [25 x i8] c"Error: Unknown operation\00", align 1
@__anon_1140 = internal unnamed_addr constant [30 x i8] c"Incremented counter (default)\00", align 1
@__anon_1147 = internal unnamed_addr constant [19 x i8] c"New counter value:\00", align 1
@__anon_1153 = internal unnamed_addr constant [25 x i8] c"Remaining compute units:\00", align 1
@builtin.zig_backend = internal unnamed_addr constant i64 2, align 8
@start.simplified_logic = internal unnamed_addr constant i1 false, align 1
@builtin.output_mode = internal unnamed_addr constant i2 1, align 1
@builtin.link_mode = internal unnamed_addr constant i1 false, align 1
@sdk.types.PUBKEY_BYTES = internal unnamed_addr constant i64 32, align 8
@Target.Cpu.Feature.Set.empty = internal unnamed_addr constant %Target.Cpu.Feature.Set zeroinitializer, align 8
@builtin.cpu = internal unnamed_addr constant %Target.Cpu { ptr @Target.bpf.cpu.v3, %Target.Cpu.Feature.Set { [5 x i64] [i64 1, i64 0, i64 0, i64 0, i64 0] }, i6 9, [7 x i8] undef }, align 8
@Target.bpf.cpu.v3 = internal unnamed_addr constant %Target.Cpu.Model { { ptr, i64 } { ptr @__anon_1276, i64 2 }, { ptr, i64 } { ptr @__anon_1276, i64 2 }, %Target.Cpu.Feature.Set { [5 x i64] [i64 1, i64 0, i64 0, i64 0, i64 0] } }, align 8
@builtin.os = internal unnamed_addr constant { { [176 x i8] }, i6, [7 x i8] } { { [176 x i8] } undef, i6 0, [7 x i8] undef }, align 8
@builtin.abi = internal unnamed_addr constant i5 0, align 1
@builtin.object_format = internal unnamed_addr constant i4 2, align 1
@Target.DynamicLinker.none = internal unnamed_addr constant %Target.DynamicLinker { [255 x i8] undef, i8 0 }, align 1
@builtin.target = internal unnamed_addr constant { %Target.Cpu, { { [176 x i8] }, i6, [7 x i8] }, i5, i4, %Target.DynamicLinker, [6 x i8] } { %Target.Cpu { ptr @Target.bpf.cpu.v3, %Target.Cpu.Feature.Set { [5 x i64] [i64 1, i64 0, i64 0, i64 0, i64 0] }, i6 9, [7 x i8] undef }, { { [176 x i8] }, i6, [7 x i8] } { { [176 x i8] } undef, i6 0, [7 x i8] undef }, i5 0, i4 2, %Target.DynamicLinker { [255 x i8] undef, i8 0 }, [6 x i8] undef }, align 8
@builtin.CallingConvention.c = internal unnamed_addr constant { <{ %builtin.CallingConvention.CommonOptions, [8 x i8] }>, i8, [7 x i8] } { <{ %builtin.CallingConvention.CommonOptions, [8 x i8] }> <{ %builtin.CallingConvention.CommonOptions { { i64, i8, [7 x i8] } { i64 undef, i8 0, [7 x i8] undef } }, [8 x i8] undef }>, i8 54, [7 x i8] undef }, align 8
@sdk.errors.SUCCESS = internal unnamed_addr constant i64 0, align 8
@sdk.types.NON_DUP_MARKER = internal unnamed_addr constant i8 -1, align 1
@sdk.entrypoint.NON_DUP_MARKER = internal unnamed_addr constant i8 -1, align 1
@sdk.types.MAX_PERMITTED_DATA_INCREASE = internal unnamed_addr constant i64 10240, align 8
@sdk.entrypoint.MAX_PERMITTED_DATA_INCREASE = internal unnamed_addr constant i64 10240, align 8
@sdk.entrypoint.STATIC_ACCOUNT_DATA = internal unnamed_addr constant i64 10328, align 8
@sdk.types.BPF_ALIGN_OF_U128 = internal unnamed_addr constant i64 8, align 8
@sdk.entrypoint.BPF_ALIGN_OF_U128 = internal unnamed_addr constant i64 8, align 8
@sdk.types.DATA_MUTABLE_BORROW_BITMASK = internal unnamed_addr constant i8 8, align 1
@sdk.syscalls.sol_log_ = internal unnamed_addr constant ptr inttoptr (i64 544561597 to ptr), align 8
@sdk.syscalls.sol_log_64_ = internal unnamed_addr constant ptr inttoptr (i64 1546269048 to ptr), align 8
@sdk.syscalls.sol_remaining_compute_units = internal unnamed_addr constant ptr inttoptr (i64 3991886574 to ptr), align 8
@__anon_1276 = internal unnamed_addr constant [3 x i8] c"v3\00", align 1

; Function Attrs: minsize noredzone nounwind optsize uwtable
define dso_local i64 @entrypoint(ptr nonnull align 1 %0) #0 {
  %2 = alloca { ptr, { ptr, i64 }, { ptr, i64 } }, align 8
  %3 = alloca { ptr, i64 }, align 8
  %4 = alloca { ptr, i64 }, align 8
  %5 = alloca ptr, align 8
  %6 = alloca [5 x %sdk.types.AccountInfo], align 8
  %7 = alloca { ptr }, align 8
  %8 = getelementptr inbounds { ptr }, ptr %7, i32 0, i32 0
  store ptr %0, ptr %8, align 8
  %9 = getelementptr inbounds { ptr }, ptr %7, i32 0, i32 0
  %10 = load ptr, ptr %9, align 8
  call void @llvm.memset.inline.p0.i64(ptr align 8 %6, i8 undef, i64 40, i1 false)
  %11 = getelementptr inbounds [5 x %sdk.types.AccountInfo], ptr %6, i64 0, i64 0
  %12 = insertvalue { ptr, i64 } poison, ptr %11, 0
  %13 = insertvalue { ptr, i64 } %12, i64 5, 1
  %14 = extractvalue { ptr, i64 } %13, 0
  %15 = extractvalue { ptr, i64 } %13, 1
  call fastcc void @sdk.entrypoint.deserialize(ptr sret({ ptr, { ptr, i64 }, { ptr, i64 } }) %2, ptr nonnull align 1 %10, ptr nonnull align 8 %14, i64 %15) #3
  %16 = getelementptr inbounds { ptr, { ptr, i64 }, { ptr, i64 } }, ptr %2, i32 0, i32 0
  %17 = load ptr, ptr %16, align 8
  store ptr %17, ptr %5, align 8
  %18 = getelementptr inbounds { ptr, { ptr, i64 }, { ptr, i64 } }, ptr %2, i32 0, i32 1
  %19 = load { ptr, i64 }, ptr %18, align 8
  store { ptr, i64 } %19, ptr %4, align 8
  %20 = getelementptr inbounds { ptr, { ptr, i64 }, { ptr, i64 } }, ptr %2, i32 0, i32 2
  %21 = load { ptr, i64 }, ptr %20, align 8
  store { ptr, i64 } %21, ptr %3, align 8
  %22 = load ptr, ptr %5, align 8
  %23 = load { ptr, i64 }, ptr %4, align 8
  %24 = load { ptr, i64 }, ptr %3, align 8
  %25 = extractvalue { ptr, i64 } %23, 0
  %26 = extractvalue { ptr, i64 } %23, 1
  %27 = extractvalue { ptr, i64 } %24, 0
  %28 = extractvalue { ptr, i64 } %24, 1
  %29 = call fastcc i16 @temp_example.processInstruction(ptr nonnull readonly align 1 %22, ptr nonnull align 8 %25, i64 %26, ptr nonnull readonly align 1 %27, i64 %28) #3
  %30 = icmp eq i16 %29, 0
  br i1 %30, label %34, label %35

31:                                               ; preds = %35, %33
  %32 = phi i64 [ %36, %35 ], [ 0, %33 ]
  ret i64 %32


... (734 more lines with similar patterns)
```

**Key Characteristics:**
- Multiple functions (`@entrypoint`, `@sdk.entrypoint.deserialize`, `@temp_example.processInstruction`, etc.)
- LLVM intrinsics: `@llvm.memset.inline.p0.i64`, `@llvm.memcpy.inline.p0.p0.i64`
- Complex struct types: `%sdk.types.AccountInfo`, `%sdk.types.Account`
- Error handling with i16 error codes
- Complex control flow with branches and phi nodes

**Result:** ❌ sbpf-linker crashes in `Instruction::from_bytes`

## The Crash Point

When sbpf-linker reaches this instruction in `byteparser.rs`:
```rust
let instruction = Instruction::from_bytes(node);
```

It's trying to parse LLVM bitcode bytes as sBPF instruction opcodes. The simple version works because the IR is minimal and perhaps maps cleanly. The SDK version fails because:

1. LLVM intrinsics don't have sBPF opcode equivalents
2. Complex types and calling conventions aren't handled
3. The parser expects machine code, not LLVM IR

## Expected Behavior

sbpf-linker should:
1. Parse the LLVM bitcode as IR (not as machine code)
2. Run LLVM optimization passes
3. Generate sBPF machine code
4. Link into final `.so`

Currently it seems to be skipping step 1-3 for complex IR patterns.
